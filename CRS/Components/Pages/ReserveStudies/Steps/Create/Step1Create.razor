@namespace CRS.Components.Pages.ReserveStudyPages.Steps.Create

@using CRS.Data
@using CRS.Models
@using CRS.Models.Security
@using CRS.Services
@using CRS.Services.Tenant
@using Microsoft.AspNetCore.Identity
@using Microsoft.EntityFrameworkCore
@using MudBlazor
@inherits OwningComponentBase
@inject IDbContextFactory<ApplicationDbContext> DbFactory
@inject UserStateService UserState
@inject ITenantContext TenantContext
@inject ITenantUserRoleService RoleService
@inject UserManager<ApplicationUser> UserManager
@inject ISnackbar Snackbar
@inject ILogger<Step1Create> Logger

<MudForm Model="Model" @ref="form">
    <MudGrid>
        <!-- Header Section -->
        <MudItem xs="12">
            <MudText Typo="Typo.h5" Class="mb-4">Community Details</MudText>
            <MudText Typo="Typo.body2" Class="text-muted">
                If you need more info, please check out the
                <MudLink Href="#" Class="link-primary fw-bold">Help Page</MudLink>.
            </MudText>
        </MudItem>

        @* HOA User Selector - Only shown to staff, auto-populated for HOA users *@
        @if (_isStaff)
        {
            <MudItem xs="12">
                <MudText Typo="Typo.h6" Class="mb-2">Customer (HOA User)</MudText>
                <MudText Typo="Typo.body2" Class="text-muted mb-2">
                    Select the HOA user this study is being created for.
                </MudText>
            </MudItem>
            <MudItem xs="12">
                <MudAutocomplete T="ApplicationUser" 
                                 Label="Select HOA User" 
                                 Value="_selectedHoaUser"
                                 ValueChanged="OnHoaUserChanged"
                                 SearchFunc="SearchHoaUsers"
                                 ToStringFunc="@(u => u == null ? "" : $"{u.FirstName} {u.LastName} ({u.Email})")"
                                 ShowProgressIndicator="true"
                                 Required="false"
                                 Clearable="true"
                                 AdornmentIcon="@Icons.Material.Filled.Person"
                                 Variant="Variant.Outlined"
                                 Dense="true">
                    <ItemTemplate Context="user">
                        <MudStack Row="true" Spacing="2" AlignItems="AlignItems.Center">
                            <MudAvatar Size="Size.Small" Color="Color.Primary">
                                @(user.FirstName?.Substring(0, 1).ToUpper() ?? "?")
                            </MudAvatar>
                            <MudStack Spacing="0">
                                <MudText Typo="Typo.body2">@user.FirstName @user.LastName</MudText>
                                <MudText Typo="Typo.caption" Color="Color.Default">@user.Email</MudText>
                            </MudStack>
                        </MudStack>
                    </ItemTemplate>
                    <NoItemsTemplate>
                        <MudText Typo="Typo.body2" Color="Color.Default" Class="pa-2">No HOA users found</MudText>
                    </NoItemsTemplate>
                </MudAutocomplete>
                <MudText Typo="Typo.caption" Color="Color.Default" Class="mt-1">
                    Leave empty if this is an internal study without a customer.
                </MudText>
            </MudItem>
            
            <MudItem xs="12">
                <MudDivider Class="my-2" />
            </MudItem>
        }
        else if (_isHoaUser)
        {
            <MudItem xs="12">
                <MudAlert Severity="Severity.Info" Dense="true" Variant="Variant.Outlined" Class="mb-2">
                    <MudText Typo="Typo.body2">
                        <MudIcon Icon="@Icons.Material.Filled.Person" Size="Size.Small" Class="mr-1" />
                        This study will be created for your account: <strong>@UserState.CurrentUser?.Email</strong>
                    </MudText>
                </MudAlert>
            </MudItem>
        }

        <!-- Community Selection Type -->
        <MudItem xs="12">
            <MudRadioGroup ValueChanged="@((bool val) => OnCommunityTypeChanged(val))">
                <MudRadio Value="false" Color="Color.Primary">Create New Community</MudRadio>
                <MudRadio Value="true" Color="Color.Primary">Select Existing Community</MudRadio>
            </MudRadioGroup>
        </MudItem>

        @if (useExistingCommunity) {
            <!-- Existing Community Selector -->
            <MudItem xs="12">
                <MudSelect T="Community" Label="Select Community" @bind-Value="selectedCommunity" Required="true" AdornmentIcon="@Icons.Material.TwoTone.LocationCity"
                           For="@(() => selectedCommunity)" SelectedValuesChanged="@OnExistingCommunitySelected">
                    @foreach (var community in existingCommunities) {
                        <MudSelectItem Value="@community">
                            @($"{community.Name} - {community.PhysicalAddress?.City}, {community.PhysicalAddress?.State}")
                        </MudSelectItem>
                    }
                </MudSelect>
            </MudItem>
        }
        else {
            <!-- New Community Form -->
            <MudItem xs="12">
                <MudTextField @bind-Value="Model.Community.Name"
                              Label="Community Name"
                              Required="true"
                              Adornment="Adornment.Start"
                              AdornmentIcon="@Icons.Material.TwoTone.LocationCity"
                              Immediate="true" />
            </MudItem>

            <!-- PHYSICAL ADDRESS SECTION -->
            <MudItem xs="12">
                <MudText Typo="Typo.h6" Class="mb-2 mt-2">Physical Address</MudText>
            </MudItem>

            <!-- Street Address -->
            <MudItem xs="12">
                <MudTextField @bind-Value="physicalAddress.Street"
                              Label="Street Address"
                              Required="true"
                              Adornment="Adornment.Start"
                              AdornmentIcon="@Icons.Material.TwoTone.EditRoad"
                              Immediate="true" />
            </MudItem>

            <!-- State, City, Zip -->
            <MudItem xs="12">
                <MudGrid>
                    <!-- State -->
                    <MudItem xs="12" sm="4">
                        <MudSelect @bind-Value="physicalAddress.State"
                                   Label="State"
                                   Required="true"
                                   Immediate="true">
                            @foreach (var state in States) {
                                <MudSelectItem Value="@state">@state</MudSelectItem>
                            }
                        </MudSelect>
                    </MudItem>

                    <!-- City -->
                    <MudItem xs="12" sm="5">
                        <MudTextField @bind-Value="physicalAddress.City"
                                      Label="City"
                                      Required="true"
                                      Adornment="Adornment.Start"
                                      AdornmentIcon="@Icons.Material.TwoTone.LocationOn"
                                      Immediate="true" />
                    </MudItem>

                    <!-- Zip Code -->
                    <MudItem xs="12" sm="3">
                        <MudTextField @bind-Value="physicalAddress.Zip"
                                      Label="Zip Code"
                                      Required="true"
                                      Adornment="Adornment.Start"
                                      AdornmentIcon="@Icons.Material.TwoTone.Mail"
                                      Immediate="true" />
                    </MudItem>
                </MudGrid>
            </MudItem>

            <!-- Mailing Address Checkbox -->
            <MudItem xs="12" Class="mt-4">
                <MudCheckBox T="bool"
                             @bind-Value="usePhysicalAsMailingAddress"
                             Label="Use physical address as mailing address"
                             Color="Color.Primary" />
            </MudItem>

            <!-- MAILING ADDRESS SECTION - displays only when checkbox is unchecked -->
            @if (!usePhysicalAsMailingAddress) {
                <MudItem xs="12">
                    <MudText Typo="Typo.h6" Class="mb-2 mt-2">Mailing Address</MudText>
                </MudItem>

                <!-- Street Address -->
                <MudItem xs="12">
                    <MudTextField @bind-Value="mailingAddress.Street"
                                  Label="Street Address"
                                  Required="true"
                                  Adornment="Adornment.Start"
                                  AdornmentIcon="@Icons.Material.TwoTone.EditRoad"
                                  Immediate="true" />
                </MudItem>

                <!-- State, City, Zip -->
                <MudItem xs="12">
                    <MudGrid>
                        <!-- State -->
                        <MudItem xs="12" sm="4">
                            <MudSelect @bind-Value="mailingAddress.State"
                                       Label="State"
                                       Required="true"
                                       Immediate="true">
                                @foreach (var state in States) {
                                    <MudSelectItem Value="@state">@state</MudSelectItem>
                                }
                            </MudSelect>
                        </MudItem>

                        <!-- City -->
                        <MudItem xs="12" sm="5">
                            <MudTextField @bind-Value="mailingAddress.City"
                                          Label="City"
                                          Required="true"
                                          Adornment="Adornment.Start"
                                          AdornmentIcon="@Icons.Material.TwoTone.LocationOn"
                                          Immediate="true" />
                        </MudItem>

                        <!-- Zip Code -->
                        <MudItem xs="12" sm="3">
                            <MudTextField @bind-Value="mailingAddress.Zip"
                                          Label="Zip Code"
                                          Required="true"
                                          Adornment="Adornment.Start"
                                          AdornmentIcon="@Icons.Material.TwoTone.Mail"
                                          Immediate="true" />
                        </MudItem>
                    </MudGrid>
                </MudItem>
            }

            <MudItem xs="12" sm="6">
                <MudDatePicker @bind-Date="Model.Community.AnnualMeetingDate" Label="Annual Meeting Date" Placeholder="Select annual meeting date (if known)" Variant="Variant.Outlined" />
            </MudItem>
        }
    </MudGrid>
</MudForm>

@code {
    [Parameter]
    public ReserveStudy Model { get; set; }

    [Parameter]
    public EventCallback<bool> OnExistingCommunityChanged { get; set; }

    [Parameter]
    public EventCallback<bool> StepValidated { get; set; }

    private MudForm form;
    private bool useExistingCommunity;
    private Community selectedCommunity;
    private List<Community> existingCommunities = new();
    private bool usePhysicalAsMailingAddress = true;
    
    // Address objects bound to the form
    private Address physicalAddress = new Address();
    private Address mailingAddress = new Address();
    
    // HOA user selection
    private ApplicationUser? _selectedHoaUser;
    private bool _isStaff;
    private bool _isHoaUser;
    private List<ApplicationUser> _hoaUsers = new();

    private List<string> States = new() {
        "AL", "AK", "AZ", "AR", "CA", "CO", "CT", "DE", "FL", "GA", "HI", "ID",
        "IL", "IN", "IA", "KS", "KY", "LA", "ME", "MD", "MA", "MI", "MN", "MS",
        "MO", "MT", "NE", "NV", "NH", "NJ", "NM", "NY", "NC", "ND", "OH", "OK",
        "OR", "PA", "RI", "SC", "SD", "TN", "TX", "UT", "VT", "VA", "WA", "WV",
        "WI", "WY"
    };

    protected override async Task OnInitializedAsync() {
        // Check user roles first
        await RoleService.InitializeAsync();
        _isStaff = RoleService.IsTenantOwner || RoleService.IsTenantSpecialist || RoleService.IsPlatformAdmin;
        _isHoaUser = RoleService.IsHOAUser;
        
        // Auto-set RequestedByUserId for HOA users
        if (_isHoaUser && UserState.CurrentUser != null) {
            Model.RequestedByUserId = UserState.CurrentUser.Id;
        }
        
        // Load HOA users for staff
        if (_isStaff) {
            await LoadHoaUsers();
        }
        
        await LoadUserCommunities();
        InitializeAddresses();
    }
    
    private async Task LoadHoaUsers() {
        if (!TenantContext.TenantId.HasValue) return;
        
        var tenantId = TenantContext.TenantId.Value;
        
        try {
            // Use UserManager to get users in HOA roles (same approach as HOAUsers.razor)
            var hoaUsers = await UserManager.GetUsersInRoleAsync("HOAUser");
            var hoaAuditors = await UserManager.GetUsersInRoleAsync("HOAAuditor");
            
            // Combine and filter by tenant
            _hoaUsers = hoaUsers.Concat(hoaAuditors)
                .Where(u => u.TenantId == tenantId)
                .DistinctBy(u => u.Id)
                .OrderBy(u => u.LastName)
                .ThenBy(u => u.FirstName)
                .ToList();
                
            Logger.LogInformation("LoadHoaUsers: Found {Count} HOA users for tenant {TenantId}", _hoaUsers.Count, tenantId);
        }
        catch (Exception ex) {
            Logger.LogError(ex, "LoadHoaUsers: Error loading HOA users");
            _hoaUsers = new List<ApplicationUser>();
        }
    }
    
    private async Task<IEnumerable<ApplicationUser>> SearchHoaUsers(string searchText, CancellationToken ct) {
        if (string.IsNullOrWhiteSpace(searchText)) {
            return _hoaUsers.Take(10);
        }
        
        var lowerSearch = searchText.ToLower();
        return _hoaUsers
            .Where(u => 
                (u.FirstName?.ToLower().Contains(lowerSearch) ?? false) ||
                (u.LastName?.ToLower().Contains(lowerSearch) ?? false) ||
                (u.Email?.ToLower().Contains(lowerSearch) ?? false))
            .Take(10);
    }
    
    private async Task OnHoaUserChanged(ApplicationUser? user) {
        _selectedHoaUser = user;
        
        // Reload communities for the selected HOA user
        await LoadUserCommunities();
        
        // Reset community selection when HOA user changes
        selectedCommunity = null;
        useExistingCommunity = false;
        
        StateHasChanged();
    }
    
    /// <summary>
    /// Gets the selected HOA user for the study.
    /// </summary>
    public ApplicationUser? GetSelectedHoaUser() => _selectedHoaUser;

    private void InitializeAddresses() {
        // Initialize physical address from model or create new
        if (Model.Community.PhysicalAddress != null) {
            physicalAddress = Model.Community.PhysicalAddress;
        } else {
            physicalAddress = new Address();
            Model.Community.PhysicalAddress = physicalAddress;
        }

        // Initialize mailing address from model or create new
        if (Model.Community.MailingAddress != null) {
            mailingAddress = Model.Community.MailingAddress;
            usePhysicalAsMailingAddress = false;
        } else {
            mailingAddress = new Address();
            usePhysicalAsMailingAddress = true;
        }

        // Set tenant ID on new community
        if (TenantContext.TenantId.HasValue && Model.Community.TenantId == 0) {
            Model.Community.TenantId = TenantContext.TenantId.Value;
        }
    }

    private async Task LoadUserCommunities() {
        if (!TenantContext.TenantId.HasValue) {
            Snackbar.Add("Unable to determine tenant context.", Severity.Error);
            return;
        }

        using var context = await DbFactory.CreateDbContextAsync();
        var currentTenantId = TenantContext.TenantId.Value;
        
        // Determine which user's communities to load
        Guid? targetUserId = null;
        
        if (_isStaff && _selectedHoaUser != null) {
            // Staff with selected HOA user: load that user's communities
            targetUserId = _selectedHoaUser.Id;
            Logger.LogInformation("LoadUserCommunities: Staff loading communities for HOA user {UserId}", targetUserId);
        } else if (_isHoaUser && UserState.CurrentUser != null) {
            // HOA user: load their own communities
            targetUserId = UserState.CurrentUser.Id;
            Logger.LogInformation("LoadUserCommunities: HOA user loading their own communities {UserId}", targetUserId);
        } else if (_isStaff) {
            // Staff without selected HOA user: load all tenant communities
            Logger.LogInformation("LoadUserCommunities: Staff loading all tenant communities");
            existingCommunities = await context.Communities
                .Include(c => c.PhysicalAddress)
                .Include(c => c.MailingAddress)
                .AsNoTracking()
                .Where(c => c.TenantId == currentTenantId)
                .OrderBy(c => c.Name)
                .ToListAsync();
            return;
        } else {
            existingCommunities = new List<Community>();
            return;
        }

        // Load communities where the user is associated via reserve studies
        // Check both ApplicationUserId (creator) and RequestedByUserId (customer)
        var userStudyCommunityIds = await context.ReserveStudies
            .AsNoTracking()
            .Where(rs => rs.TenantId == currentTenantId && 
                        (rs.ApplicationUserId == targetUserId || rs.RequestedByUserId == targetUserId))
            .Select(rs => rs.CommunityId)
            .Distinct()
            .ToListAsync();

        if (!userStudyCommunityIds.Any()) {
            existingCommunities = new List<Community>();
            Logger.LogInformation("LoadUserCommunities: No communities found for user {UserId}", targetUserId);
            return;
        }

        existingCommunities = await context.Communities
            .Include(c => c.PhysicalAddress)
            .Include(c => c.MailingAddress)
            .AsNoTracking()
            .Where(c => userStudyCommunityIds.Contains(c.Id))
            .OrderBy(c => c.Name)
            .ToListAsync();
            
        Logger.LogInformation("LoadUserCommunities: Found {Count} communities for user {UserId}", 
            existingCommunities.Count, targetUserId);
    }

    private async Task OnCommunityTypeChanged(bool useExisting) {
        useExistingCommunity = useExisting;
        if (!useExisting) {
            selectedCommunity = null;
            physicalAddress = new Address();
            mailingAddress = new Address();
            Model.Community = new Community {
                PhysicalAddress = physicalAddress
            };
            
            if (TenantContext.TenantId.HasValue) {
                Model.Community.TenantId = TenantContext.TenantId.Value;
            }
            
            usePhysicalAsMailingAddress = true;
        }
        await OnExistingCommunityChanged.InvokeAsync(IsExistingCommunity());
    }

    private void OnExistingCommunitySelected() {
        if (selectedCommunity != null) {
            Model.Community = selectedCommunity;
            InitializeAddresses();
        }
    }

    public bool IsExistingCommunity() {
        return useExistingCommunity;
    }

    public bool IsNewCommunity() {
        return !useExistingCommunity && Model?.Community != null && Model.Community.Id == Guid.Empty;
    }

    public async Task<bool> ValidateAsync() {
        if (!TenantContext.TenantId.HasValue) {
            Snackbar.Add("Unable to determine tenant context.", Severity.Error);
            await StepValidated.InvokeAsync(false);
            return false;
        }
        
        if (Model?.Community == null) {
            Snackbar.Add("Community data is missing.", Severity.Error);
            await StepValidated.InvokeAsync(false);
            return false;
        }
        
        await form.Validate();
        bool valid = form.IsValid;

        // Sync HOA user selection to model
        if (_isStaff && _selectedHoaUser != null) {
            Model.RequestedByUserId = _selectedHoaUser.Id;
        } else if (_isHoaUser && UserState.CurrentUser != null) {
            Model.RequestedByUserId = UserState.CurrentUser.Id;
        }

        // Sync addresses to model before saving
        if (!useExistingCommunity) {
            Model.Community.PhysicalAddress = physicalAddress;
            
            if (usePhysicalAsMailingAddress) {
                Model.Community.MailingAddress = null;
                Model.Community.MailingAddressId = null;
            } else {
                Model.Community.MailingAddress = mailingAddress;
            }
        }
        
        if (Model.Community.TenantId != TenantContext.TenantId.Value) {
            Model.Community.TenantId = TenantContext.TenantId.Value;
        }

        await StepValidated.InvokeAsync(valid);
        return valid;
    }

    public async Task<bool> SaveNewCommunityIfNeededAsync() {
        Logger.LogInformation("SaveNewCommunityIfNeededAsync: Starting. Model.Community is {State}, Model.CommunityId={CommunityId}", 
            Model?.Community == null ? "null" : "not null", 
            Model?.CommunityId);
        
        // If community is already null (already processed) or CommunityId is already set, consider it saved
        if (Model?.Community == null) {
            Logger.LogInformation("SaveNewCommunityIfNeededAsync: Community is null, returning true");
            return true;
        }
        
        // If CommunityId is already set and valid, the community was already saved
        if (Model.CommunityId != Guid.Empty) {
            Logger.LogInformation("SaveNewCommunityIfNeededAsync: CommunityId already set to {CommunityId}, returning true", Model.CommunityId);
            return true;
        }
        
        if (!IsNewCommunity()) {
            Logger.LogInformation("SaveNewCommunityIfNeededAsync: Not a new community, returning true");
            return true;
        }

        try {
            await using var context = await DbFactory.CreateDbContextAsync();
            
            if (TenantContext.TenantId.HasValue) {
                Model.Community.TenantId = TenantContext.TenantId.Value;
            }

            if (Model.Community.Id == Guid.Empty) {
                Model.Community.Id = Guid.CreateVersion7();
            }
            
            Logger.LogInformation("SaveNewCommunityIfNeededAsync: About to save community with Id={CommunityId}, Name={Name}, TenantId={TenantId}", 
                Model.Community.Id, Model.Community.Name, Model.Community.TenantId);

            // Ensure physical address has an ID and set the FK
            if (Model.Community.PhysicalAddress != null) {
                if (Model.Community.PhysicalAddress.Id == Guid.Empty) {
                    Model.Community.PhysicalAddress.Id = Guid.CreateVersion7();
                }
                Model.Community.PhysicalAddressId = Model.Community.PhysicalAddress.Id;
            }

            // Ensure mailing address has an ID if provided
            if (Model.Community.MailingAddress != null) {
                if (Model.Community.MailingAddress.Id == Guid.Empty) {
                    Model.Community.MailingAddress.Id = Guid.CreateVersion7();
                }
                Model.Community.MailingAddressId = Model.Community.MailingAddress.Id;
            }

            context.Communities.Add(Model.Community);
            await context.SaveChangesAsync();
            
            Logger.LogInformation("SaveNewCommunityIfNeededAsync: Community saved successfully with Id={CommunityId}", Model.Community.Id);
            
            // IMPORTANT: Set the CommunityId on the Model to ensure it's available for the reserve study
            Model.CommunityId = Model.Community.Id;
            
            Logger.LogInformation("SaveNewCommunityIfNeededAsync: Set Model.CommunityId={CommunityId}", Model.CommunityId);
            
            // Detach to prevent tracking issues later
            context.Entry(Model.Community).State = EntityState.Detached;
            if (Model.Community.PhysicalAddress != null) {
                context.Entry(Model.Community.PhysicalAddress).State = EntityState.Detached;
            }
            if (Model.Community.MailingAddress != null) {
                context.Entry(Model.Community.MailingAddress).State = EntityState.Detached;
            }

            return true;
        }
        catch (Exception ex) {
            Logger.LogError(ex, "SaveNewCommunityIfNeededAsync: Error saving community");
            Snackbar.Add($"Error saving community: {ex.Message}", Severity.Error);
            return false;
        }
    }
}

